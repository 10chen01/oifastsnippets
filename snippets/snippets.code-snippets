{
    "oi-mainfunc":{
        "prefix": ["main", "oi-main"],
        "body": [
            "#include <${1:bits/stdc++.h}>",
            "using namespace std;",
            "${2|int,signed|} main(){",
            "\t$0",
            "\treturn 0;",
            "}"
        ],
        "description": "main function of C++"
    },
    "oi-sort-stl":{
        "prefix": ["sort", "oi-sort", "oi-sort-stl"],
        "body": [
            "sort(begin(${1:vec}), end(${1:vec}), [${2|&,=|}](${3:Type} a,${3:Type} b){",
            "\treturn ${4:a<b};",
            "});"
        ],
        "description": "sort array from stl"
    },
    "oi-fast-iostream":{
        "prefix": ["fast-io", "oi-fast-io", "oi-fast-iostream"],
        "body": [
            "ios::sync_with_stdio(false);",
            "${1}.tie(0);",
            "${2}.tie(0);"
        ],
        "description": "fast iostream(break sync with stdio)"
    },
    "oi-freopen":{
        "prefix": ["oi-freopen", "oi-fileio-freopen"],
        "body": [
            "freopen(\"${1:input}.in\", \"r\", stdin);",
            "freopen(\"${2:output}.out\", \"w\", stdout);"
        ],
        "description": "freopen input and output file"
    },
    // "oi-fstream":{
    //     "prefix": ["oi-fstream", "oi-fileio-fstream", "fin", "fout"],
    //     "body": [
    //         "ifstream fin(\"${1:input}.in\");",
    //         "ofstream fout(\"${2:output}.out\");"
    //     ],
    //     "description": "fstream input and output file"
    // },
    "oi-fin": {
        "prefix": ["fin", "oi-fin", "oi-ifstream"],
        "body": [
            "ifstream ${1:fin}(\"${1:input.in}\");"
        ],
        "description": "fstream input file"
    },
    "oi-fout": {
        "prefix": ["fout", "oi-fout", "oi-ofstream"],
        "body": [
            "ofstream ${1:fout}(\"${2:output.out}\");"
        ],
        "description": "fstream output file"
    },
    "oi-autolonglong":{
        "prefix": ["oi-autolonglong", "oi-inttolonglong"],
        "body": [
            "#define int long long"
        ],
        "description": "reference int to long long"
    },
    "oi-dfs-matrix":{
        "prefix": ["dfs", "oi-dfs", "oi-dfs-matrix", "oi-dfs-matrix-template"],
        "body": [
            "const int _dx[] = {0, 0, 1, -1};",
            "const int _dy[] = {1, -1, 0, 0};",
            "bool _vis[${1:m}][${2:n}]",
            "void dfs(int _x, int _y, int _deep, int& _ans){",
            "\tif(${3:_check(_x,_y)}){",
            "\t\t${4};",
            "\t\treturn;",
            "\t}",
            "\tfor(int _i = 0; _i < 4; _i++){",
            "\t\tint _nx = _x + _dx[_i];",
            "\t\tint _ny = _y + _dy[_i];",
            "\t\tif(!${5:_isvaild(_x,_y)}) continue;",
            "\t\t_vis[_nx][_ny] = true;",
            "\t\tdfs(_nx, _ny, _deep + 1,_ans);",
            "\t\t_vis[_nx][_ny] = false",
            "\t}",
            "}"
        ],
        "description": "dfs template on matrix"
    },
    "oi-ds-binary-tree-with-pointer" : {
        "prefix": ["binary-tree-p", "oi-binary-tree-p", "bntp", "btp", "oi-btp", "oi-ds-btp"],
        "body" : [
            "template<typename DataType>",
            "class BinaryTree {",
            "protected:",
            "\tstruct BinaryTreeNode {",
            "\t\tDataType data;",
            "\t\tBinaryTreeNode* left;",
            "\t\tBinaryTreeNode* right;",
            "\t\tBinaryTreeNode(): data(DataType()), left(nullptr), right(nullptr){}",
            "\t\tBinaryTreeNode(DataType data): data(data), left(nullptr), right(nullptr){}",
            "\t\tBinaryTreeNode(BinaryTreeNode* node){",
            "\t\t\tthis->data = node->data;",
            "\t\t\tthis->left = BinaryTreeNode(node->left);",
            "\t\t\tthis->right = BinaryTreeNode(node->right);",
            "\t\t}",
            "\t\tBinaryTreeNode(DataType data, BinaryTreeNode* left, BinaryTreeNode* right):",
            "\t\t\tdata(data), left(BinaryTreeNode(left)), right(BinaryTreeNode(right)){}",
            "\t\t~BinaryTreeNode(){",
            "\t\t\tdelete left;",
            "\t\t\tdelete right;",
            "\t\t}",
            "\t};",
            "\tBinaryTreeNode* root;",
            "public:",
            "\tBinaryTree(): root(nullptr){}",
            "\tBinaryTree(BinaryTree<DataType>& data){",
            "\t\tthis->root = BinaryTreeNode(data.root);",
            "\t}",
            "\tBinaryTree(BinaryTreeNode* root){",
            "\t\tthis->root = BinaryTreeNode(root);",
            "\t}",
            "\tBinaryTree(DataType data): root(data, nullptr, nullptr){}",
            "\t~BinaryTree(){",
            "\t\tdelete this->root;",
            "\t}",
            "\tbool operator==(const BinaryTree<DataType>& tree){",
            "\t\tif(tree.root == nullptr && this->root == nullptr) return true;",
            "\t\telse if(tree.root == nullptr && this->root!=nullptr) return false;",
            "\t\telse if(tree.root != nullptr && this->root==nullptr) return false;",
            "\t\telse return ",
            "\t\t\tBinaryTree<DataType>(this->root->left)==",
            "\t\t\tBinaryTree<DataType>(tree.root->left) && ",
            "\t\t\tBinaryTree<DataType>(this->root->right)==",
            "\t\t\tBinaryTree<DataType>(tree.root->right);\t",
            "\t}",
            "\tbool operator<(const BinaryTree& tree){",
            "\t\tif(*this == tree) return false;",
            "\t\telse if(tree == nullptr) return true;",
            "\t\telse if(this->root == nullptr) return false;",
            "\t\telse if(",
            "\t\t\tBinaryTree<DataType>(this->root->left) == tree || ",
            "\t\t\tBinaryTree<DataType>(this->root->right) == tree)){",
            "\t\t\treturn true;",
            "\t\t}else{",
            "\t\t\treturn ",
            "\t\t\t\tBinaryTree<DataType>(this->root->left) < tree || ",
            "\t\t\t\tBinaryTree<DataType>(this->root->right) < tree;",
            "\t\t}",
            "\t}",
            "\tbool operator>(const BinaryTree<DataType>& tree){",
            "\t\treturn tree < *this;",
            "\t}",
            "\tbool operator>=(const BinaryTree<DataType>& tree){",
            "\t\treturn tree < *this || *this == tree;",
            "\t}",
            "\tbool operator<=(const BinaryTree<DataType>& tree){",
            "\t\treturn *this < tree || *this == tree;",
            "\t}",
            "\tint deep(){",
            "\t\tif(this->root == nullptr) return 0;",
            "\t\telse return ",
            "\t\t\t1 + ",
            "\t\t\tmax(",
            "\t\t\t\tBinaryTree<DataType>(this->root->left).deep(), ",
            "\t\t\t\tBinaryTree<DataType>(this->root->right).deep());",
            "\t}",
            "\tint size(){",
            "\t\tif(this->root == nullptr) return 0;",
            "\t\telse return BinaryTree(this->left).size() + BinaryTree(this->right).size() + 1;",
            "\t}",
            "\tBinaryTree<DataType> left(){",
            "\t\treturn BinaryTree<DataType>(this->root->left);",
            "\t}",
            "\tBinaryTree<DataType> right(){",
            "\t\treturn BinaryTree<DataType>(this->root->right);",
            "\t}",
            "\tDataType rootData(){",
            "\t\treturn this->root->data;",
            "\t}",
            "",
            "\tBinaryTree<DataType>& setRootData(DataType data){",
            "\t\tif(this->root == nullptr){",
            "\t\t\tthis->root = new BinaryTreeNode(data);",
            "\t\t}else{",
            "\t\t\tthis->root->data = data;",
            "\t\t}",
            "\t\treturn this;",
            "\t}",
            "",
            "\tBinaryTree<DataType>& setRoot(BinaryTree<DataType> data){",
            "\t\tthis->root = new BinaryTreeNode(data.root);",
            "\t}",
            "",
            "\tBinaryTree<DataType>& setLeft(BinaryTree<DataType> sub){",
            "\t\tthis->root->left = new BinaryTreeNode(sub.root);",
            "\t\treturn this;",
            "\t}",
            "\t",
            "\tBinaryTree<DataType>& setRight(BinaryTree<DataType> sub){",
            "\t\tthis->root->right = new BinaryTreeNode(sub.root);",
            "\t\treturn this;",
            "\t}",
            "",
            "\tBinaryTreeNode* getRootAsNode(){",
            "\t\treturn this->root;",
            "\t}",
            "",
            "\tvoid clear(){",
            "\t\tdelete this->root;",
            "\t\tthis->root = nullptr;",
            "\t}",
            "};"
        ],
        "description": "BinaryTree with point implementation.",
        "isFileTemplate": true
    },
    "oi-ds-list-with-pointer" : {
        "prefix": ["oi-list", "list-with-pointer", "oi-list-with-pointer"],
        "body": [
            "template<typename T>",
            "class List {",
            "\tprotected:",
            "\tstruct ListNode",
            "\t{",
            "\t\tT data;",
            "\t\tListNode* next;",
            "\t\tListNode(T data_) : data { data_ }, next { nullptr } {}",
            "\t\tListNode(ListNode* node) : {",
            "\t\t\tthis->data = node->data;",
            "\t\t\tthis->next = node->next;",
            "\t\t}",
            "\t\tListNode(T data_, ListNode* nxt){",
            "\t\t\tthis->data = data_;",
            "\t\t\tthis->next = nxt;",
            "\t\t}",
            "\t};",
            "\tListNode* head;",
            "\tListNode* tail;  ",
            "\tpublic:",
            "\tList(){",
            "\t\tthis->head = new ListNode(nullptr);",
            "\t\tthis->tail = new ListNode(nullptr);",
            "\t\tthis->tail = this->head;",
            "\t}",
            "\tList(T root){",
            "\t\tthis->tail = new ListNode(root);",
            "\t\tthis->head = new ListNode(new T(), this->tail);",
            "\t}",
            "\tList(ListNode* root){",
            "\t\tthis->tail = new ListNode(root);",
            "\t\tthis->head = new ListNode(new T, this->tail);",
            "\t}",
            "\tList(List<T>& lst) {",
            "\t\tthis->head = new ListNode(lst.head);",
            "\t\tthis->tail = new ListNode(lst.tail);",
            "\t}",
            "\tint length() {",
            "\t\tint cnt = 0;",
            "\t\tfor(ListNode* p=head; p!=lst.tail; p=p->next){",
            "\t\t\tcnt++;",
            "\t\t}",
            "\t\treturn cnt;",
            "\t}",
            "\tvoid push_back(T data){",
            "\t\tListNode* p = new ListNode(data);",
            "\t\tthis->tail->next = p;",
            "\t\tthis->tail = p;",
            "\t}",
            "\tT pop_back(){",
            "\t\tT data =this->tail->data;",
            "\t\tthis->tail = nullptr;",
            "\t\treturn data;",
            "\t}",
            "\tT back(){",
            "\t\treturn this->tail->data;",
            "\t}",
            "\tvoid push_front(T data){",
            "\t\tListNode* p = new ListNode(data, this->head->next);",
            "\t\tthis->head->next = p;",
            "\t}",
            "\tT pop_front(){",
            "\t\tT data = this->head->next->data;",
            "\t\tListNode* prefix = this->head->next;",
            "\t\tthis->head->next = prefix->next;",
            "\t\treturn data;",
            "\t}",
            "\tT front(){",
            "\t\tListNode* prefix = this->head->next;",
            "\t\treturn prefix->data;",
            "\t}",
            "\tvoid insert(T data, unsigned index){",
            "\t\tListNode* temp = new ListNode(data);",
            "\t\tListNode* p = this->head;",
            "\t\tfor(int i=0; i<index; i++){",
            "\t\t\tp = p->next;",
            "\t\t}",
            "\t\ttemp->next = p->next;",
            "\t\tp->next = temp;",
            "\t}",
            "\tT& operator[](unsigned index) {",
            "\t\tListNode* p = this->head;",
            "\t\tfor(int i=0; i<=index; i++){",
            "\t\t\tp = p->next;",
            "\t\t}",
            "\t\treturn p->data;",
            "\t}",
            "\tvoid insert(List<T> data, unsigned index){",
            "\t\tListNode* p = this->head;",
            "\t\tfor(int i=0;i<index;i++){",
            "\t\t\tp = p->next;",
            "\t\t}",
            "\t\tdata.tail->next = p->next;",
            "\t\tp->next = data.head->next;",
            "\t}",
            "};"
        ],
        "description": "List with pointer implementation.",
        "isFileTemplate": true
    },
    "oi-ds-find-set": {
        "prefix" : ["find-set", "oi-find-set", "oi-ds-find-set"],
        "body": [
            "#include<map>",
            "#include<vector>",
            "#include<functional>",
            "#include<set>",
            "template<typename T, bool PathCompression=false>",
            "class FindSet {",
            "protected:",
            "\tstd::map<T, T> parent;",
            "\tT _find_with_path_compression(T x){",
            "\t\tif(x == this->parent[x]) return x;",
            "\t\telse return this->parent[x] = this->_find_with_path_compression(this->parent[x]);",
            "\t}",
            "\tT _find_withou_path_compression(T x){",
            "\t\tif(x == this->parent[x]) return x;",
            "\t\telse return this->_find_withou_path_compression(this->parent[x]);",
            "\t}",
            "\tT _find(T x){",
            "\t\tif constexpr(PathCompression){",
            "\t\t\treturn this->_find_with_path_compression(x);",
            "\t\t}else{",
            "\t\t\treturn this->_find_withou_path_compression(x);",
            "\t\t}",
            "\t}",
            "",
            "\tvoid _initalize_element(T x) noexcept{",
            "\t\tthis->parent[x] = x;",
            "\t}",
            "",
            "\tvoid _merge(T x, T y, std::function<bool(T, T)> cmp = [](T x1, T x2){",
            "\t\treturn true;",
            "\t}){",
            "\t\tif(this->parent->find(x) == this->parent->end())",
            "\t\t\tthis->_initalize_element(x);",
            "\t\tif(this->parent->find(y) == this->parent->end())",
            "\t\t\tthis->_initalize_element(y);",
            "\t\tif(this->_find(x) != this->_find(y)){",
            "\t\t\tif(cmp(x, y)){",
            "\t\t\t\tthis->parent[this->_find(x)] = this->_find(y);",
            "\t\t\t}else{",
            "\t\t\t\tthis->parent[this->_find(y)] = this->_find(x);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "public:",
            "\tFindSet() : parent(new std::map()){}",
            "\tFindSet(std::vector<T> U){",
            "\t\tfor(auto x : U){",
            "\t\t\tthis->_initalize_element(x);",
            "\t\t}",
            "\t}",
            "\tFindSet(std::vector<T> U, std::vector<std::pair<T, T>> rel){",
            "\t\tfor(auto x : U){",
            "\t\t\tparent[x] = x;",
            "\t\t}",
            "\t\tfor(auto p : rel){",
            "\t\t\tthis->_merge(p.first, p.second);",
            "\t\t}",
            "\t}",
            "\tFindSet(std::vector<T> U, std::vector<std::pair<T, T>> rel, ",
            "\t\tstd::function<bool(T, T)> cmp = [](T x1, T x2){return true;}){",
            "\t\t\tfor(T x : U){",
            "\t\t\t\tthis->_initalize_element(x);",
            "\t\t\t}",
            "\t\t\tfor(std::pair<T, T> p : rel) {",
            "\t\t\t\tthis->_merge(p.first, p.second, cmp);",
            "\t\t\t}",
            "\t}",
            "\tFindSet(std::vector<std::pair<T, T>> rel){",
            "\t\tfor(std::pair<T, T> p: rel){",
            "\t\t\tthis->_merge(p.first, p.second);",
            "\t\t}",
            "\t}",
            "\tFindSet(std::vector<std::pair<T, T>> rel,",
            "\t\tstd::function<bool(T, T)> cmp = [](T x1, T x2){return true;}) {",
            "\t\tfor(std::pair<T, T> x: rel){",
            "\t\t\tthis->_merge(x.first, x.second);",
            "\t\t}",
            "\t}",
            "\tauto allElementCount() -> unsigned{",
            "\t\treturn this->parent->size();",
            "\t}",
            "\tunsigned allBlockCount(){",
            "\t\tstd::map<T, bool> block_count;",
            "\t\tfor(auto p: this->parent){",
            "\t\t\tif(block_count.find(this->_find(p.first)) == block_count.end())",
            "\t\t\t\tblock_count[this->_find(p.first)] = true;",
            "\t\t\t// }else{",
            "\t\t\t//\t block_count[this->_find(p.first)]++;",
            "\t\t\t// }",
            "\t\t}",
            "\t\treturn block_count.size();",
            "\t}",
            "\tauto allElementSet() -> std::set<T> {",
            "\t\tstd::set<T> res;",
            "\t\tfor(auto p: this->parent){",
            "\t\t\tres.insert(p.first);",
            "\t\t\tres.insert(p.second);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tauto allBlockSet() -> std::set<T> {",
            "\t\tstd::map<T, std::set<T>> block_set;",
            "\t\tfor(auto p: this->AllElementSet()){",
            "\t\t\tblock_set[this->_find(p)].insert(p);",
            "\t\t}",
            "\t\tstd::set<std::set<T>> res;",
            "\t\tfor(auto p: block_set){",
            "\t\t\tres.insert(p.second);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tbool inSameBlock(T a, T b){",
            "\t\treturn this->_find(a) == this->_find(b);",
            "\t}",
            "\tvoid addItem(T x){",
            "\t\tthis->_initalize_element(x);",
            "\t}",
            "\tvoid addItem(T x, T y){",
            "\t\tthis->_merge(x, y);",
            "\t}",
            "\tvoid addItem(T x, T y, std::function<bool(T, T)> cmp){",
            "\t\tthis->_merge(x, y, cmp);",
            "\t}",
            "};"
        ],
        "description": "Datastructure of joint set.",
        "isFileTemplate": true
    },
    "oi-functional-struct" : {
        "prefix": ["functional-struct", "oi-functional-struct", "functor", "oi-functor"],
        "body": [
            "struct ${1:FunctionalStruct} {",
            "\t${2:void} operator()($3) {",
            "\t$0",
            "\t}",
            "} $4;"
        ],
        "description": "Functional struct.",
    },
    "oi-commonly-use-header" : {
        "prefix" : ["oi-header", "oi-commonly-use-header"],
        "body" : [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
        ]
    },
    "oi-commonly-use-header-without-bits-cpp" : {
        "prefix": ["oi-header-msvc", "oi-header-llvm", "oi-header-w"],
        "body": [
            "#include <iostream>",
            "#include <cstring>",
            "#include <cctype>",
            "#include <algorithm>",
            "#include <vector>",
            "#include <string>",
            "#include <set>",
            "#include <map>",
            "#include <queue>",
            "#include <stack>",
            "#include <unordered_set>",
            "#include <unordered_map>",
            "#include <cmath>",
            "#include <cstdio>",
            "#include <functional>",
            "#include <numeric>",
            "#include <utility>",
            "#include <limits>",
            "#include <ctime>",
            "#include <cmath>",
            "#include <cstdio>",
            "#include <string>",
            "#include <cstdlib>",
            "#include <cassert>",
            "#include <regex>",
            "using namespace std;"
        ],
        "isFileTemplate": true
    },
    "oi-for-loop" : {
        "prefix": [
            "oi-for", "for-loop", "for-with-count"
        ],
        "body": [
            "for(int ${1:_count}=0;${1:_count}<${2:n};${1:_count}++){",
            "\t$0",
            "}"
        ],
        "description": "for loop with count."
    },
    "oi-for-each" : {
        "prefix": ["foreach", "for-each", "for-item"],
        "body": [
            "for(auto ${1:item}: ${2:container}){",
            "\t$0",
            "}"
        ]
    },
    "oi-for-each-with-index" : {
        "prefix": ["foreach-with-index", "for-each-with-index", "for-item-with-index"],
        "body": [
            "for(int ${1:_index}=0;${1:_index}<${2:container}.size();${1:_index}++){",
            "\tauto ${3:item} = ${2:container}[${1:_index}];",
            "\t$0",
            "}"
        ]
    }
}